<!DOCTYPE html>
<html lang="en" class="h-full bg-slate-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator & Solver</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure canvas is sharp on all displays */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 2px solid #334155; /* slate-700 */
            border-radius: 0.5rem; /* rounded-lg */
        }
        /* Gradient buttons with transforms */
        .btn-gradient {
            background-size: 200% auto;
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
            transform: scale(1);
        }
        .btn-gradient:hover {
            background-position: right center;
            transform: scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn-gradient:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4 bg-gradient-to-br from-slate-900 to-slate-950 text-slate-100">

    <div class="w-full max-w-5xl flex flex-col gap-6">
        
        <!-- Header -->
        <header class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                Maze Generator & Solver
            </h1>
            <p class="text-slate-400 mt-2">Using Kruskal's Algorithm & A* Search</p>
        </header>

        <!-- Controls -->
        <div class="flex flex-col sm:flex-row flex-wrap gap-4 p-4 bg-slate-800 rounded-lg shadow-lg justify-center items-center">
            <div class="flex items-center gap-3">
                <label for="mazeWidth" class="font-medium text-slate-300">Width:</label>
                <input type="number" id="mazeWidth" value="21" min="5" max="101" step="2" class="bg-slate-700 border border-slate-600 rounded-md px-3 py-2 w-20 text-center focus:outline-none focus:ring-2 focus:ring-cyan-400">
            </div>
            <div class="flex items-center gap-3">
                <label for="mazeHeight" class="font-medium text-slate-300">Height:</label>
                <input type="number" id="mazeHeight" value="21" min="5" max="101" step="2" class="bg-slate-700 border border-slate-600 rounded-md px-3 py-2 w-20 text-center focus:outline-none focus:ring-2 focus:ring-cyan-400">
            </div>
            
            <div class="flex items-center gap-3">
                <label for="solveAlgorithm" class="font-medium text-slate-300">Algorithm:</label>
                <select id="solveAlgorithm" class="bg-slate-700 border border-slate-600 rounded-md px-3 py-2 pr-8 text-center focus:outline-none focus:ring-2 focus:ring-cyan-400">
                    <option value="astar" selected>A* Search (Shortest)</option>
                    <option value="bfs">Breadth-First (Shortest)</option>
                    <option value="dfs">Depth-First (A Path)</option>
                </select>
            </div>

            <button id="generateButton" class="btn-gradient w-full sm:w-auto bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-600 text-white font-bold py-2 px-6 rounded-md shadow-md">
                Generate Maze
            </button>
            <button id="solveButton" class="btn-gradient w-full sm:w-auto bg-gradient-to-r from-cyan-500 to-cyan-600 hover:from-cyan-600 hover:to-cyan-500 text-white font-bold py-2 px-6 rounded-md shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                Solve Maze
            </button>
        </div>

        <!-- Message Area -->
        <div id="messageArea" class="text-center text-lg text-yellow-400 h-6"></div>

        <!-- Canvas Container -->
        <div id="canvasContainer" class="w-full h-auto flex justify-center">
            <canvas id="mazeCanvas"></canvas>
        </div>
    </div>

    <script type="module">
        // --- DOM Elements ---
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const widthInput = document.getElementById('mazeWidth');
        const heightInput = document.getElementById('mazeHeight');
        const generateButton = document.getElementById('generateButton');
        const solveButton = document.getElementById('solveButton');
        const algorithmSelect = document.getElementById('solveAlgorithm');
        const messageArea = document.getElementById('messageArea');
        const canvasContainer = document.getElementById('canvasContainer');

        // --- Icons ---
        const startIcon = new Image();
        const endIcon = new Image();

        // --- Constants ---
        const WALL = 1;
        const PATH = 0;
        const IMPERFECTION_RATE = 0.2; // Chance to remove an internal wall (20%)
        const COLORS = {
            WALL: '#1e293b',    // slate-800
            WALL_SHADOW: '#0f172a', // slate-950 (darker for shadow)
            PATH: '#f1f5f9',    // slate-100 (lighter path)
            START: '#22c55e',   // green-500
            END: '#ef4444',     // red-500
            VISITED: 'rgba(103, 232, 249, 0.5)', // cyan-300 with 50% opacity
            SOLUTION: '#fde047', // yellow-400
            SOLUTION_PULSE: '#fef9c3' // yellow-100 (for pulsing)
        };

        // --- Maze State ---
        let maze = [];
        let mazeWidth = 0;
        let mazeHeight = 0;
        let cellSize = 0;
        let startPos = {};
        let endPos = {};
        let solutionPath = [];
        let isSolving = false;
        let animationFrameId = null;
        let solutionAnimationId = null; // For the pulse animation
        let parentDSU = []; // Disjoint Set Union array for Kruskal's

        // --- Solver State (shared across algorithms) ---
        let openSet = []; // Used as a priority queue for A*, queue for BFS, stack for DFS
        let visited = new Set();
        let parentMap = new Map();
        // A* specific state
        let gCost = new Map();
        let fCost = new Map();

        // --- DSU Helper Functions ---
        // Finds the representative (root) of the set containing element i
        function findDSU(i) {
            if (parentDSU[i] === i) {
                return i;
            }
            // Path compression
            return parentDSU[i] = findDSU(parentDSU[i]);
        }

        // Unites the sets containing elements i and j
        function unionDSU(i, j) {
            let rootI = findDSU(i);
            let rootJ = findDSU(j);
            if (rootI !== rootJ) {
                parentDSU[rootI] = rootJ;
                return true; // Union was successful
            }
            return false; // Already in the same set
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            
            // Set up icons
            // Using an "arrow down circle" for start
            const startSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${COLORS.START}">
              <path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm.75 4.75v8.69l3.22-3.22a.75.75 0 111.06 1.06l-4.5 4.5a.75.75 0 01-1.06 0l-4.5-4.5a.75.75 0 111.06-1.06l3.22 3.22V7a.75.75 0 011.5 0z" clip-rule="evenodd" />
            </svg>`;
            
            // Using a "trophy" for end
            const endSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${COLORS.END}">
              <path fill-rule="evenodd" d="M10.5 2.25a.75.75 0 00-1.5 0v.31c-1.12.233-2.07.69-2.818 1.25-.11.082-.212.17-.306.264a.75.75 0 00-1.06 1.06c.095.095.183.187.265.307 1.018 1.666 1.018 3.706 0 5.372-.082.12-.17.212-.265.307a.75.75 0 001.06 1.06c.094.095.196.182.306.264 1.34 1.004 3.018 1.59 4.818 1.59s3.478-.586 4.818-1.59c.11-.082.212-.17.306.264a.75.75 0 001.06-1.06c-.095-.095-.183-.187-.265-.307-1.018-1.666-1.018-3.706 0-5.372.082-.12.17-.212.265-.307a.75.75 0 00-1.06-1.06c-.094-.095-.196-.182-.306-.264A9.69 9.69 0 0015 2.56V2.25a.75.75 0 00-1.5 0v.31c-.496-.068-.997-.105-1.5-.105s-1.004.037-1.5.105V2.25zM4.625 6.375a.75.75 0 00-1.5 0v6c0 1.657 1.343 3 3 3h.75v2.25a.75.75 0 001.5 0v-2.25h6v2.25a.75.75 0 001.5 0v-2.25h.75c1.657 0 3-1.343 3-3v-6a.75.75 0 00-1.5 0v6a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 014.625 12.375v-6zM11.25 18a.75.75 0 00-1.5 0v3.75a.75.75 0 001.5 0V18zm1.5 3.75a.75.75 0 001.5 0V18a.75.75 0 00-1.5 0v3.75z" clip-rule="evenodd" />
            </svg>`;
            
            // Convert SVG string to base64 data URL
            startIcon.src = `data:image/svg+xml;base64,${btoa(startSVG)}`;
            endIcon.src = `data:image/svg+xml;base64,${btoa(endSVG)}`;

            // Redraw the maze once icons are loaded
            startIcon.onload = () => { if (maze.length > 0) resizeAndDraw(); };
            endIcon.onload = () => { if (maze.length > 0) resizeAndDraw(); };

            generateButton.addEventListener('click', generateNewMaze);
            solveButton.addEventListener('click', solveMaze);
            window.addEventListener('resize', resizeAndDraw);
            generateNewMaze();
        });

        // --- Maze Generation (Kruskal's Algorithm) ---
        function generateNewMaze() {
            if (isSolving) {
                cancelAnimationFrame(animationFrameId);
                isSolving = false;
            }
            if (solutionAnimationId) {
                cancelAnimationFrame(solutionAnimationId);
                solutionAnimationId = null;
            }
            
            // Get and sanitize dimensions (must be odd)
            let w = parseInt(widthInput.value);
            let h = parseInt(heightInput.value);
            mazeWidth = w % 2 === 0 ? w + 1 : w;
            mazeHeight = h % 2 === 0 ? h + 1 : h;
            widthInput.value = mazeWidth;
            heightInput.value = mazeHeight;
            
            solutionPath = [];
            messageArea.textContent = '';
            solveButton.disabled = false;

            // Initialize maze grid with all walls
            maze = Array(mazeHeight).fill(0).map(() => Array(mazeWidth).fill(WALL));
            
            // Initialize Disjoint Set Union (DSU) structure
            parentDSU = Array(mazeWidth * mazeHeight).fill(0);
            
            const walls = [];
            
            // Initialize cells and collect walls
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    const index = y * mazeWidth + x;
                    
                    // If it's a cell (odd, odd)
                    if (y % 2 !== 0 && x % 2 !== 0) {
                        maze[y][x] = PATH;
                        parentDSU[index] = index; // Each cell is its own set
                    }
                    // If it's an internal wall
                    else if (y % 2 !== 0 && x % 2 === 0) { // Vertical wall
                        walls.push({ x, y, type: 'v' });
                    } 
                    else if (y % 2 === 0 && x % 2 !== 0) { // Horizontal wall
                        walls.push({ x, y, type: 'h' });
                    }
                }
            }

            // Shuffle the walls
            shuffle(walls);

            // Kruskal's algorithm
            for (const wall of walls) {
                let cell1_x, cell1_y, cell2_x, cell2_y;

                if (wall.type === 'v') { // Vertical wall
                    cell1_x = wall.x - 1;
                    cell1_y = wall.y;
                    cell2_x = wall.x + 1;
                    cell2_y = wall.y;
                } else { // Horizontal wall
                    cell1_x = wall.x;
                    cell1_y = wall.y - 1;
                    cell2_x = wall.x;
                    cell2_y = wall.y + 1;
                }

                // Get DSU indices
                const index1 = cell1_y * mazeWidth + cell1_x;
                const index2 = cell2_y * mazeWidth + cell2_x;

                // If cells are not already connected, union them and remove the wall
                if (unionDSU(index1, index2)) {
                    maze[wall.y][wall.x] = PATH;
                }
            }

            // --- Create loops by removing some walls (make maze "imperfect") ---
            // This runs *after* the perfect maze is generated
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    // If this is a wall
                    if (maze[y][x] === WALL) {
                        // Check if it's an internal wall (separating two paths)
                        // (y % 2 !== 0 && x % 2 === 0) -> vertical internal wall
                        // (y % 2 === 0 && x % 2 !== 0) -> horizontal internal wall
                        const isInternalWall = (y % 2 !== 0 && x % 2 === 0) || (y % 2 === 0 && x % 2 !== 0);

                        if (isInternalWall && Math.random() < IMPERFECTION_RATE) {
                            maze[y][x] = PATH;
                        }
                    }
                }
            }

            // Define start and end points
            startPos = { x: 1, y: 0 };
            maze[startPos.y][startPos.x] = PATH; // Carve entry

            // Find a random exit on the bottom edge
            let endX = (Math.floor(Math.random() * (Math.floor(mazeWidth / 2))) * 2) + 1;
            endPos = { x: endX, y: mazeHeight - 1 };
            maze[endPos.y][endPos.x] = PATH; // Carve exit

            resizeAndDraw();
        }

        /* We no longer need carvePassages for Kruskal's
        function carvePassages(cx, cy) {
...
        }
        */

        // --- Heuristic Function (Manhattan Distance) ---
        function calculateHeuristic(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        // --- Maze Solving (Router Function) ---
        function solveMaze() {
            if (isSolving) return;
            if (solutionAnimationId) {
                cancelAnimationFrame(solutionAnimationId);
                solutionAnimationId = null;
            }

            isSolving = true;
            solveButton.disabled = true;
            generateButton.disabled = true;
            algorithmSelect.disabled = true; // Disable dropdown during solve
            messageArea.textContent = 'Solving...';
            
            // Clear previous solution state
            solutionPath = [];
            openSet = [];
            visited = new Set();
            parentMap = new Map();
            gCost = new Map();
            fCost = new Map();

            const startKey = `${startPos.x},${startPos.y}`;
            const endKey = `${endPos.x},${endPos.y}`;
            
            // Add start node to open set and visited
            openSet.push(startPos);
            visited.add(startKey);

            // Get selected algorithm
            const algorithm = algorithmSelect.value;
            let solveStepFunction;

            if (algorithm === 'astar') {
                // --- A* Setup ---
                gCost.set(startKey, 0);
                const hCost = calculateHeuristic(startPos.x, startPos.y, endPos.x, endPos.y);
                fCost.set(startKey, hCost);
                solveStepFunction = solveStepAStar;

            } else if (algorithm === 'bfs') {
                // --- BFS Setup (Queue) ---
                // No extra setup needed, openSet will be used as a queue
                solveStepFunction = solveStepBFS;

            } else if (algorithm === 'dfs') {
                // --- DFS Setup (Stack) ---
                // No extra setup needed, openSet will be used as a stack
                solveStepFunction = solveStepDFS;
            }

            // Start the solving animation loop
            function animateSolve() {
                if (!isSolving) return; // Stop if cancelled
                
                const result = solveStepFunction(endKey, startKey);
                
                if (result === 'found') {
                    // --- Solution Found ---
                    messageArea.textContent = 'Solved!';
                    isSolving = false;
                    generateButton.disabled = false;
                    algorithmSelect.disabled = false;
                    solveButton.disabled = true; // Can't re-solve
                    
                    // Reconstruct path
                    let curr = endPos;
                    while (`${curr.x},${curr.y}` !== startKey) {
                        solutionPath.push(curr);
                        curr = parentMap.get(`${curr.x},${curr.y}`);
                    }
                    solutionPath.push(startPos);
                    solutionPath.reverse();
                    
                    // Start pulsing animation
                    animateSolution();

                } else if (result === 'not_found') {
                    // --- No Solution ---
                    messageArea.textContent = 'Maze is unsolvable!';
                    isSolving = false;
                    generateButton.disabled = false;
                    algorithmSelect.disabled = false;

                } else {
                    // --- Continue Solving ---
                    animationFrameId = requestAnimationFrame(animateSolve);
                }
            }
            
            animationFrameId = requestAnimationFrame(animateSolve);
        }

        // --- A* Solver Step ---
        function solveStepAStar(endKey, startKey) {
            if (openSet.length === 0) return 'not_found';

            // Find node in openSet with the lowest fCost
            let lowestFIndex = 0;
            for (let i = 1; i < openSet.length; i++) {
                const key = `${openSet[i].x},${openSet[i].y}`;
                const lowestKey = `${openSet[lowestFIndex].x},${openSet[lowestFIndex].y}`;
                if (fCost.get(key) < fCost.get(lowestKey)) {
                    lowestFIndex = i;
                }
            }
            
            // Get and remove the best node from the openSet
            const current = openSet.splice(lowestFIndex, 1)[0];
            const currentKey = `${current.x},${current.y}`;

            drawVisitedCell(current, startKey, endKey);
            
            if (currentKey === endKey) return 'found';

            // Get neighbors
            const neighbors = getNeighbors(current);

            for (const n of neighbors) {
                const nKey = `${n.x},${n.y}`;
                // Calculate tentative gCost
                const tentativeGCost = gCost.get(currentKey) + 1;

                // If this path to neighbor is better OR neighbor hasn't been visited
                if (!gCost.has(nKey) || tentativeGCost < gCost.get(nKey)) {
                    parentMap.set(nKey, current);
                    gCost.set(nKey, tentativeGCost);
                    const hCost = calculateHeuristic(n.x, n.y, endPos.x, endPos.y);
                    fCost.set(nKey, tentativeGCost + hCost);

                    if (!visited.has(nKey)) {
                        openSet.push(n);
                        visited.add(nKey);
                    }
                }
            }
            return 'continue';
        }

        // --- BFS Solver Step ---
        function solveStepBFS(endKey, startKey) {
            if (openSet.length === 0) return 'not_found';
            
            // Get node from front of queue
            const current = openSet.shift(); 
            const currentKey = `${current.x},${current.y}`;

            drawVisitedCell(current, startKey, endKey);

            if (currentKey === endKey) return 'found';

            // Get neighbors
            const neighbors = getNeighbors(current);

            for (const n of neighbors) {
                const nKey = `${n.x},${n.y}`;
                if (!visited.has(nKey)) {
                    visited.add(nKey);
                    parentMap.set(nKey, current);
                    openSet.push(n);
                }
            }
            return 'continue';
        }

        // --- DFS Solver Step ---
        function solveStepDFS(endKey, startKey) {
            if (openSet.length === 0) return 'not_found';
            
            // Get node from top of stack
            const current = openSet.pop(); 
            const currentKey = `${current.x},${current.y}`;

            drawVisitedCell(current, startKey, endKey);

            if (currentKey === endKey) return 'found';

            // Get neighbors
            const neighbors = getNeighbors(current);

            for (const n of neighbors) {
                const nKey = `${n.x},${n.y}`;
                if (!visited.has(nKey)) {
                    visited.add(nKey);
                    parentMap.set(nKey, current);
                    openSet.push(n);
                }
            }
            return 'continue';
        }

        // --- Helper for getting valid neighbors ---
        function getNeighbors(current) {
            const neighbors = [
                { x: current.x, y: current.y - 1 },
                { x: current.x + 1, y: current.y },
                { x: current.x, y: current.y + 1 },
                { x: current.x - 1, y: current.y }
            ];

            return neighbors.filter(n => 
                n.x >= 0 && n.x < mazeWidth &&
                n.y >= 0 && n.y < mazeHeight &&
                maze[n.y][n.x] === PATH
            );
        }

        // --- Helper for drawing the visited cell ---
        function drawVisitedCell(current, startKey, endKey) {
            const currentKey = `${current.x},${current.y}`;
            if (currentKey !== startKey && currentKey !== endKey) {
                ctx.fillStyle = COLORS.VISITED;
                ctx.fillRect(current.x * cellSize, current.y * cellSize, cellSize, cellSize);
            }
        }

        // --- Drawing & Sizing ---
        function resizeAndDraw() {
            if (!maze.length) return;

            // Stop any running animations on resize
            if (isSolving) {
                cancelAnimationFrame(animationFrameId);
                isSolving = false;
                // Re-enable buttons if solving was interrupted
                generateButton.disabled = false;
                solveButton.disabled = false;
                algorithmSelect.disabled = false;
                messageArea.textContent = 'Resized. Click Solve to try again.';
            }
            if (solutionAnimationId) {
                cancelAnimationFrame(solutionAnimationId);
                solutionAnimationId = null;
            }

            // Fit canvas to container width
            const containerWidth = canvasContainer.clientWidth;
            cellSize = Math.floor(containerWidth / mazeWidth);
            
            // Ensure cell size is at least 1px
            cellSize = Math.max(1, cellSize);

            canvas.width = cellSize * mazeWidth;
            canvas.height = cellSize * mazeHeight;

            canvas.style.width = `${canvas.width}px`;
            canvas.style.height = `${canvas.height}px`;

            drawMaze();
        }

        function drawMaze(solutionColorOverride = null) {
            // Draw the base path color everywhere first
            ctx.fillStyle = COLORS.PATH;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === WALL) {
                        // Draw shadow first (offset)
                        ctx.fillStyle = COLORS.WALL_SHADOW;
                        ctx.fillRect(x * cellSize + 2, y * cellSize + 2, cellSize, cellSize);
                        // Draw main wall on top
                        ctx.fillStyle = COLORS.WALL;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw solution path if it exists
            if (solutionPath.length > 0) {
                ctx.fillStyle = solutionColorOverride || COLORS.SOLUTION;
                for (const cell of solutionPath) {
                    // Don't draw over start/end
                    if (cell.x === startPos.x && cell.y === startPos.y) continue;
                    if (cell.x === endPos.x && cell.y === endPos.y) continue;
                    
                    ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                }
            }

            // Draw start point
            if (startIcon.complete && startIcon.naturalHeight !== 0) {
                ctx.drawImage(startIcon, startPos.x * cellSize, startPos.y * cellSize, cellSize, cellSize);
            } else {
                ctx.fillStyle = COLORS.START;
                ctx.fillRect(startPos.x * cellSize, startPos.y * cellSize, cellSize, cellSize);
            }

            // Draw end point
            if (endIcon.complete && endIcon.naturalHeight !== 0) {
                ctx.drawImage(endIcon, endPos.x * cellSize, endPos.y * cellSize, cellSize, cellSize);
            } else {
                ctx.fillStyle = COLORS.END;
                ctx.fillRect(endPos.x * cellSize, endPos.y * cellSize, cellSize, cellSize);
            }
        }

        // --- Solution Pulse Animation ---
        function animateSolution() {
            // Calculate pulse
            const pulseAmount = (Math.sin(Date.now() / 250) + 1) / 2; // Oscillates 0.0 to 1.0
            const pulseColor = lerpColor(COLORS.SOLUTION, COLORS.SOLUTION_PULSE, pulseAmount);

            // Redraw the maze with the new pulse color
            drawMaze(pulseColor);
            
            // Loop
            solutionAnimationId = requestAnimationFrame(animateSolution);
        }

        // --- Helpers ---
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            // 3 digit
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } 
            // 6 digit
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return { r, g, b };
        }

        function lerpColor(hexA, hexB, amount) {
            const rgbA = hexToRgb(hexA);
            const rgbB = hexToRgb(hexB);
            
            const r = Math.round((1 - amount) * rgbA.r + amount * rgbB.r);
            const g = Math.round((1 - amount) * rgbA.g + amount * rgbB.g);
            const b = Math.round((1 - amount) * rgbA.b + amount * rgbB.b);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

    </script>
</body>
</html>



